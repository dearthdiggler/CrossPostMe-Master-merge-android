<!--
This file is auto-generated by an assistant. It contains focused, actionable guidance
for AI coding agents working in this repository. It's intentionally short and concrete.
-->

# Copilot instructions for contributors and AI agents

Repository snapshot (discoverable):

- Main working folder: `app/` with two subprojects:
  - `backend/`: FastAPI backend (Python, async MongoDB via Motor, Pydantic models)
  - `frontend/`: React frontend (Create React App + craco, Tailwind, shadcn/ui, Radix UI)

The backend and frontend are decoupled but communicate via HTTP API. Data flows from the frontend UI to the backend API, which persists to MongoDB. See `README.md` for security and environment setup details (env vars, credential handling, and production security best practices).

Quick start checklist:

1. List `app/` to confirm files and manifests. Example (PowerShell):

````powershell
Get-ChildItem -Path .\app -Force -Recurse -Depth 2
```powershell

2. Identify stack from these files:

- `backend/requirements.txt` — Python FastAPI stack (FastAPI, uvicorn, motor, pydantic, pytest, linters)
- `backend/server.py` — Entrypoint for backend API, includes routers from `backend/routes/`
- `frontend/package.json` — Frontend is Create React App (uses `craco`); scripts: `start`, `build`, `test`

3. For environment variables, credential setup, and security, see `README.md` (section: Security & Environment Setup)

Big-picture architecture:

- Backend: FastAPI app (`backend/server.py`), async MongoDB via Motor, expects env vars (`MONGO_URL`, `DB_NAME`). Route modules in `backend/routes/` (e.g., `ads.py`, `platforms.py`, `ai.py`) export `router` and are included via `app.include_router(...)`.
- Frontend: React 19 app (CRA + craco) in `frontend/`, styled with Tailwind and Radix UI. Scripts in `frontend/package.json`.
- Data flow: Frontend calls backend API; backend persists to MongoDB. Timestamps are serialized as ISO strings before insert; Pydantic models often ignore MongoDB `_id` via `ConfigDict(extra="ignore")`.

Key files to inspect:

- `backend/server.py` — app entry, router mounting, CORS config, DB client lifecycle, example endpoints (`/api/status`)
- `backend/routes/*.py` — route modules (must export `router`)
- `backend/requirements.txt` — dependencies and dev tools (pytest, black, isort, flake8, mypy)
- `frontend/package.json` — scripts, dependencies, package manager (yarn v1)
- `frontend/src/` — React components and pages (UI: `components/`, `pages/`)

Backend route patterns:

- Each route module defines an `APIRouter` with a `prefix` and registers endpoints. Example: `ads.py` uses `router = APIRouter(prefix="/api/ads", tags=["ads"])` and exports `router`.
- DB pattern: route modules call a local `get_db()` (creates `AsyncIOMotorClient` from `MONGO_URL`, selects `DB_NAME`). Example: `db = get_db()` then `await db.ads.find({...}).to_list(1000)` or `await db.ads.insert_one(obj.dict())`.
- Error handling: endpoints raise `HTTPException` for 404s.
- Route examples:
  - Create: `@router.post('/', response_model=Model)` → insert and return Pydantic model
  - List: `@router.get('/', response_model=List[Model])` → `await db.collection.find(query).to_list(1000)`
  - Read single: `@router.get('/{id}')` → `await db.collection.find_one({'id': id})` else raise 404
  - Update: `await db.collection.update_one({'id': id}, {'$set': update_data})` then return updated doc

Async & DB gotchas:

- Prefer reusing the main Motor client in `server.py` (avoid extra connections from per-route `get_db()`)
- Timestamps: convert to ISO string before insert; convert back to `datetime` on read

If you add or modify backend routes:

- Export a `router` APIRouter and include it in `backend/server.py` with `app.include_router(your_module.router)`
- Add Pydantic models in `backend/models.py` and use `ConfigDict(extra='ignore')` to ignore MongoDB `_id`

Environment & secrets:

- Backend reads env vars from `.env` (loaded via `dotenv` in `server.py`). Required: `MONGO_URL`, `DB_NAME`, `CORS_ORIGINS` (see usages in `server.py` and routes)
- Never commit secrets. Use `.env` locally. See `README.md` for required vars and security practices

Developer workflows (PowerShell):

- Backend:

  ```powershell
  python -m venv .venv; .\.venv\Scripts\Activate.ps1
  pip install -r app/backend/requirements.txt
  # set .env or environment variables, then:
  uvicorn server:app --reload --host 0.0.0.0 --port 8000 --app-dir app/backend
````

- Frontend:

  ```powershell
  cd app/frontend
  yarn install
  yarn start
  ```

  <!--
  Auto-generated guidance for AI coding agents working in this repository.
  Keep it short and concrete — reference the exact files and patterns used here.
  -->

Tests, linters, and quality tools:

- Backend: pytest, black, isort, flake8, mypy (see `backend/requirements.txt`). Run `pytest` from `app/backend`
- Frontend: CRA test runner (`yarn test`), ESLint via devDependencies

Common tasks & gotchas:

- When adding backend routes, export an `APIRouter` and include in `server.py`
- Database reads: use `.to_list(1000)` and map to Pydantic models (see `routes/ads.py`, `platforms.py`)
- Prefer using shared Motor client in `server.py` (avoid per-route clients)
- Frontend build/postcss/tailwind: see `craco.config.js`

Integration & deployment:

- Dockerfiles (`Dockerfile.backend`, `Dockerfile.frontend`) and `docker-compose.yml` at repo root for containerized dev/production
- Backend expects env vars (see `README.md` for setup)

Where to look for examples:

- `app/backend/server.py` — app entry, CORS, DB client lifecycle
- `app/backend/routes/ads.py`, `platforms.py`, `ai.py` — backend route/module patterns
- `app/frontend/package.json`, `craco.config.js`, `frontend/src/` — frontend structure

CI:

- Add workflows under `.github/workflows/` that run `pip install -r app/backend/requirements.txt && pytest` (backend) and `yarn install && yarn test --ci` (frontend)

  If something is unclear (deployment target, DB connection details, CI expectations), stop and ask the maintainer — include which manifests you inspected and a short plan.

  -- End of file --

  ```

  ```

<!-- NEW CONCISE COPILOT INSTRUCTIONS (appended by assistant) -->

````instructions
<!--
Authoritative, concise guidance for AI agents working in this repo.
-->

<!--
Canonical Copilot instructions for this repository.
This file is the single-source-of-truth quick guide for AI coding agents and contributors.
Keep it short and concrete (20-50 lines).
-->

# Copilot instructions (canonical)

Repository layout (high signal):
- `app/backend/` — FastAPI backend (entry: `server.py`, routes: `routes/`, models: `models.py`). Uses Motor (async MongoDB).
- `app/frontend/` — Create React App with CRACO, Tailwind and shadcn/ui (entry: `frontend/package.json`, config: `craco.config.js`).

First checks (files to open):
- `app/backend/server.py` — router mounts, DB client lifecycle, env usage (`MONGO_URL`, `DB_NAME`, `CORS_ORIGINS`).
- `app/backend/routes/*` — router pattern examples (`ads.py`, `platforms.py`, `ai.py`).
- `app/frontend/package.json`, `craco.config.js` — dev/start/build scripts and webpack/tailwind config.

Project-specific conventions:
- Routes: each `backend/routes/*.py` exports an `APIRouter` and is included in `server.py` via `app.include_router(...)`.
- DB: prefer reusing the shared Motor client in `server.py`. Avoid creating duplicate Motor clients in route modules (`get_db()` patterns).
- Data: datetimes are serialized to ISO strings before insert; Pydantic models often use `model_config = ConfigDict(extra="ignore")` to ignore MongoDB `_id`.
- Query/list pattern: use `.to_list(1000)` then map to Pydantic models for lists/pagination.

Dev commands (PowerShell):
```powershell
# Backend
python -m venv .venv; .\.venv\Scripts\Activate.ps1
pip install -r app/backend/requirements.txt
uvicorn server:app --reload --app-dir app/backend

# Frontend
cd app/frontend
yarn install
yarn start
```

Tests & quality:
- Backend: `pytest` in `app/backend`; formatting via `black .`; linters available in `app/backend/requirements.txt` (flake8, mypy).
- Frontend: CRA test runner (`yarn test`); ESLint via devDependencies.

Deployment & infra notes:
- Dockerfiles (`Dockerfile.backend`, `Dockerfile.frontend`) and `docker-compose.yml` are provided for containerized runs.
- Backend reads `.env` via dotenv in `server.py` — do not commit secrets.

Where to look for examples:
- `app/backend/routes/ads.py`, `platforms.py`, `ai.py` — concrete router + DB usage
- `app/backend/server.py` — app entry, CORS, DB client lifecycle
- `app/frontend/package.json`, `craco.config.js`, `frontend/src/` — frontend structure and components

If you add CI: create `.github/workflows/` that run `pip install -r app/backend/requirements.txt && pytest` and `cd app/frontend && yarn install && yarn test --ci`.

If anything is unclear (deployment target, DB credentials, CI expectations), make the best possible decision based on the above and implement.

- Dockerfiles (Dockerfile.backend, Dockerfile.frontend) and `docker-compose.yml` are present for containerized runs.
- Backend loads `.env` via dotenv in `server.py` — do not commit secrets.

Where to look for examples:
- `app/backend/routes/ads.py`, `platforms.py`, `ai.py` — router/db examples
- `app/backend/server.py` — include_router, client lifecycle, CORS
- `app/frontend/package.json`, `craco.config.js`, `frontend/src/` — frontend structure and components

If you need to add CI: create `.github/workflows/` entries that run `pip install -r app/backend/requirements.txt && pytest` and `cd app/frontend && yarn install && yarn test --ci`.

If anything is unclear (deployment target, DB credentials, CI requirements), make the best possible decision based on the above and implement.

## Coding agent post-edit checks

- After making any code changes (including small edits), run the following locally in `app/backend` before committing or opening a PR:
  1. Format and lint:
    - ruff: `ruff check . --fix` (or `ruff check .` to only report)
    - black: `black .` (if configured)
    - isort: `isort .` (if configured)
  2. Static typing and linters:
    - mypy: `mypy .` (fix or annotate any new errors)
    - flake8: `flake8 .` (if present)
  3. Tests:
    - pytest: `pytest -q` and ensure all tests pass

- If any of the above fail, fix locally and re-run them. Do not open a PR that introduces new linter or test failures. If a change intentionally alters typing or test expectations, and make the best possible decision based on the above and implement.
if any of the above fail

These checks help avoid fragile CI runs and keep the repository healthy. Always include a brief note in the commit message like: "ran ruff, black, mypy, pytest - all green" when these have been executed.

Run   `git commit -m "ran ruff, black, mypy, pytest - all green"`
````
